== Physical Plan ==
AdaptiveSparkPlan (38)
+- == Final Plan ==
   * HashAggregate (23)
   +- ShuffleQueryStage (22), Statistics(sizeInBytes=72.0 B, rowCount=1)
      +- Exchange (21)
         +- * HashAggregate (20)
            +- NativeProject (19)
               +- NativeSortMergeJoin Inner (18)
                  :- NativeSort (9)
                  :  +- InputAdapter (8)
                  :     +- AQEShuffleRead (7)
                  :        +- ShuffleQueryStage (6), Statistics(sizeInBytes=28.9 KiB, rowCount=722)
                  :           +- NativeShuffleExchange (5)
                  :              +- NativeProject (4)
                  :                 +- NativeFilter (3)
                  :                    +- InputAdapter (2)
                  :                       +- NativeParquetScan  (1)
                  +- NativeSort (17)
                     +- InputAdapter (16)
                        +- AQEShuffleRead (15)
                           +- ShuffleQueryStage (14), Statistics(sizeInBytes=68.0 KiB, rowCount=2.00E+3)
                              +- NativeShuffleExchange (13)
                                 +- NativeFilter (12)
                                    +- InputAdapter (11)
                                       +- NativeParquetScan  (10)
+- == Initial Plan ==
   HashAggregate (37)
   +- Exchange (36)
      +- HashAggregate (35)
         +- Project (34)
            +- SortMergeJoin Inner (33)
               :- Sort (28)
               :  +- Exchange (27)
               :     +- Project (26)
               :        +- Filter (25)
               :           +- Scan parquet  (24)
               +- Sort (32)
                  +- Exchange (31)
                     +- Filter (30)
                        +- Scan parquet  (29)


(24) Scan parquet 
Output [4]: [l_partkey#1, l_extendedprice#2, l_discount#3, l_shipdate#4]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1995-09-01), LessThan(l_shipdate,1995-10-01), IsNotNull(l_partkey)]
ReadSchema: struct<l_partkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(2) InputAdapter
Input [4]: [l_partkey#1, l_extendedprice#2, l_discount#3, l_shipdate#4]
Arguments: [#5, #2, #3, #4]

(3) NativeFilter
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Condition : (((isnotnull(l_shipdate#4) AND (l_shipdate#4 >= 1995-09-01)) AND (l_shipdate#4 < 1995-10-01)) AND isnotnull(l_partkey#1))

(4) NativeProject
Output [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]
Input [4]: [#5#1, #2#2, #3#3, #4#4]

(5) NativeShuffleExchange
Input [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]
Arguments: hashpartitioning(l_partkey#1, 5), ENSURE_REQUIREMENTS, [plan_id=1]

(6) ShuffleQueryStage
Output [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]
Arguments: X

(7) AQEShuffleRead
Input [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]
Arguments: coalesced

(8) InputAdapter
Input [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]

(9) NativeSort
Input [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]
Arguments: [l_partkey#1 ASC NULLS FIRST], false

(29) Scan parquet 
Output [2]: [p_partkey#6, p_type#7]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(p_partkey)]
ReadSchema: struct<p_partkey:bigint,p_type:string>

(11) InputAdapter
Input [2]: [p_partkey#6, p_type#7]
Arguments: [#8, #7]

(12) NativeFilter
Input [2]: [#8#6, #7#7]
Condition : isnotnull(p_partkey#6)

(13) NativeShuffleExchange
Input [2]: [#8#6, #7#7]
Arguments: hashpartitioning(p_partkey#6, 5), ENSURE_REQUIREMENTS, [plan_id=2]

(14) ShuffleQueryStage
Output [2]: [#8#6, #7#7]
Arguments: X

(15) AQEShuffleRead
Input [2]: [#8#6, #7#7]
Arguments: coalesced

(16) InputAdapter
Input [2]: [#8#6, #7#7]

(17) NativeSort
Input [2]: [#8#6, #7#7]
Arguments: [p_partkey#6 ASC NULLS FIRST], false

(18) NativeSortMergeJoin
Left keys [1]: [l_partkey#1]
Right keys [1]: [p_partkey#6]
Join type: Inner
Join condition: None

(19) NativeProject
Output [3]: [l_extendedprice#2, l_discount#3, p_type#7]
Input [5]: [l_partkey#1, l_extendedprice#2, l_discount#3, #8#6, #7#7]

(20) HashAggregate [codegen id : 1]
Input [3]: [l_extendedprice#2, l_discount#3, p_type#7]
Keys: []
Functions [2]: [partial_sum(CASE WHEN StartsWith(p_type#7, PROMO) THEN (l_extendedprice#2 * (1 - l_discount#3)) ELSE 0.0000 END), partial_sum((l_extendedprice#2 * (1 - l_discount#3)))]
Aggregate Attributes [4]: [sum#9, isEmpty#10, sum#11, isEmpty#12]
Results [4]: [sum#13, isEmpty#14, sum#15, isEmpty#16]

(21) Exchange
Input [4]: [sum#13, isEmpty#14, sum#15, isEmpty#16]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=3]

(22) ShuffleQueryStage
Output [4]: [sum#13, isEmpty#14, sum#15, isEmpty#16]
Arguments: X

(23) HashAggregate [codegen id : 2]
Input [4]: [sum#13, isEmpty#14, sum#15, isEmpty#16]
Keys: []
Functions [2]: [sum(CASE WHEN StartsWith(p_type#7, PROMO) THEN (l_extendedprice#2 * (1 - l_discount#3)) ELSE 0.0000 END), sum((l_extendedprice#2 * (1 - l_discount#3)))]
Aggregate Attributes [2]: [sum(CASE WHEN StartsWith(p_type#7, PROMO) THEN (l_extendedprice#2 * (1 - l_discount#3)) ELSE 0.0000 END)#17, sum((l_extendedprice#2 * (1 - l_discount#3)))#18]
Results [1]: [((100.00 * sum(CASE WHEN StartsWith(p_type#7, PROMO) THEN (l_extendedprice#2 * (1 - l_discount#3)) ELSE 0.0000 END)#17) / sum((l_extendedprice#2 * (1 - l_discount#3)))#18) AS promo_revenue#19]

(24) Scan parquet 
Output [4]: [l_partkey#1, l_extendedprice#2, l_discount#3, l_shipdate#4]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1995-09-01), LessThan(l_shipdate,1995-10-01), IsNotNull(l_partkey)]
ReadSchema: struct<l_partkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(25) Filter
Input [4]: [l_partkey#1, l_extendedprice#2, l_discount#3, l_shipdate#4]
Condition : (((isnotnull(l_shipdate#4) AND (l_shipdate#4 >= 1995-09-01)) AND (l_shipdate#4 < 1995-10-01)) AND isnotnull(l_partkey#1))

(26) Project
Output [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]
Input [4]: [l_partkey#1, l_extendedprice#2, l_discount#3, l_shipdate#4]

(27) Exchange
Input [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]
Arguments: hashpartitioning(l_partkey#1, 5), ENSURE_REQUIREMENTS, [plan_id=4]

(28) Sort
Input [3]: [l_partkey#1, l_extendedprice#2, l_discount#3]
Arguments: [l_partkey#1 ASC NULLS FIRST], false, 0

(29) Scan parquet 
Output [2]: [p_partkey#6, p_type#7]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(p_partkey)]
ReadSchema: struct<p_partkey:bigint,p_type:string>

(30) Filter
Input [2]: [p_partkey#6, p_type#7]
Condition : isnotnull(p_partkey#6)

(31) Exchange
Input [2]: [p_partkey#6, p_type#7]
Arguments: hashpartitioning(p_partkey#6, 5), ENSURE_REQUIREMENTS, [plan_id=5]

(32) Sort
Input [2]: [p_partkey#6, p_type#7]
Arguments: [p_partkey#6 ASC NULLS FIRST], false, 0

(33) SortMergeJoin
Left keys [1]: [l_partkey#1]
Right keys [1]: [p_partkey#6]
Join type: Inner
Join condition: None

(34) Project
Output [3]: [l_extendedprice#2, l_discount#3, p_type#7]
Input [5]: [l_partkey#1, l_extendedprice#2, l_discount#3, p_partkey#6, p_type#7]

(35) HashAggregate
Input [3]: [l_extendedprice#2, l_discount#3, p_type#7]
Keys: []
Functions [2]: [partial_sum(CASE WHEN StartsWith(p_type#7, PROMO) THEN (l_extendedprice#2 * (1 - l_discount#3)) ELSE 0.0000 END), partial_sum((l_extendedprice#2 * (1 - l_discount#3)))]
Aggregate Attributes [4]: [sum#9, isEmpty#10, sum#11, isEmpty#12]
Results [4]: [sum#13, isEmpty#14, sum#15, isEmpty#16]

(36) Exchange
Input [4]: [sum#13, isEmpty#14, sum#15, isEmpty#16]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=6]

(37) HashAggregate
Input [4]: [sum#13, isEmpty#14, sum#15, isEmpty#16]
Keys: []
Functions [2]: [sum(CASE WHEN StartsWith(p_type#7, PROMO) THEN (l_extendedprice#2 * (1 - l_discount#3)) ELSE 0.0000 END), sum((l_extendedprice#2 * (1 - l_discount#3)))]
Aggregate Attributes [2]: [sum(CASE WHEN StartsWith(p_type#7, PROMO) THEN (l_extendedprice#2 * (1 - l_discount#3)) ELSE 0.0000 END)#17, sum((l_extendedprice#2 * (1 - l_discount#3)))#18]
Results [1]: [((100.00 * sum(CASE WHEN StartsWith(p_type#7, PROMO) THEN (l_extendedprice#2 * (1 - l_discount#3)) ELSE 0.0000 END)#17) / sum((l_extendedprice#2 * (1 - l_discount#3)))#18) AS promo_revenue#19]

(38) AdaptiveSparkPlan
Output [1]: [promo_revenue#19]
Arguments: isFinalPlan=true

