== Physical Plan ==
AdaptiveSparkPlan (43)
+- == Final Plan ==
   InputAdapter (26)
   +- AQEShuffleRead (25)
      +- ShuffleQueryStage (24), Statistics(sizeInBytes=1256.0 B, rowCount=1)
         +- NativeShuffleExchange (23)
            +- NativeProject (22)
               +- NativeSortMergeJoin Inner (21)
                  :- NativeSort (8)
                  :  +- InputAdapter (7)
                  :     +- AQEShuffleRead (6)
                  :        +- ShuffleQueryStage (5), Statistics(sizeInBytes=9.6 KiB, rowCount=100)
                  :           +- NativeShuffleExchange (4)
                  :              +- NativeFilter (3)
                  :                 +- InputAdapter (2)
                  :                    +- NativeParquetScan  (1)
                  +- NativeSort (20)
                     +- ConvertToNative (19)
                        +- * Filter (18)
                           +- * HashAggregate (17)
                              +- AQEShuffleRead (16)
                                 +- ShuffleQueryStage (15), Statistics(sizeInBytes=4.7 KiB, rowCount=100)
                                    +- Exchange (14)
                                       +- * HashAggregate (13)
                                          +- NativeProject (12)
                                             +- NativeFilter (11)
                                                +- InputAdapter (10)
                                                   +- NativeParquetScan  (9)
+- == Initial Plan ==
   Sort (42)
   +- Exchange (41)
      +- Project (40)
         +- SortMergeJoin Inner (39)
            :- Sort (30)
            :  +- Exchange (29)
            :     +- Filter (28)
            :        +- Scan parquet  (27)
            +- Sort (38)
               +- Filter (37)
                  +- HashAggregate (36)
                     +- Exchange (35)
                        +- HashAggregate (34)
                           +- Project (33)
                              +- Filter (32)
                                 +- Scan parquet  (31)


(27) Scan parquet 
Output [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(s_suppkey)]
ReadSchema: struct<s_suppkey:bigint,s_name:string,s_address:string,s_phone:string>

(2) InputAdapter
Input [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Arguments: [#5, #2, #3, #4]

(3) NativeFilter
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Condition : isnotnull(s_suppkey#1)

(4) NativeShuffleExchange
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Arguments: hashpartitioning(s_suppkey#1, 5), ENSURE_REQUIREMENTS, [plan_id=1]

(5) ShuffleQueryStage
Output [4]: [#5#1, #2#2, #3#3, #4#4]
Arguments: X

(6) AQEShuffleRead
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Arguments: coalesced

(7) InputAdapter
Input [4]: [#5#1, #2#2, #3#3, #4#4]

(8) NativeSort
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Arguments: [s_suppkey#1 ASC NULLS FIRST], false

(31) Scan parquet 
Output [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01), IsNotNull(l_suppkey)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(10) InputAdapter
Input [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]
Arguments: [#10, #7, #8, #9]

(11) NativeFilter
Input [4]: [#10#6, #7#7, #8#8, #9#9]
Condition : (((isnotnull(l_shipdate#9) AND (l_shipdate#9 >= 1996-01-01)) AND (l_shipdate#9 < 1996-04-01)) AND isnotnull(l_suppkey#6))

(12) NativeProject
Output [3]: [l_suppkey#6, l_extendedprice#7, l_discount#8]
Input [4]: [#10#6, #7#7, #8#8, #9#9]

(13) HashAggregate [codegen id : 1]
Input [3]: [l_suppkey#6, l_extendedprice#7, l_discount#8]
Keys [1]: [l_suppkey#6]
Functions [1]: [partial_sum((l_extendedprice#7 * (1 - l_discount#8)))]
Aggregate Attributes [2]: [sum#11, isEmpty#12]
Results [3]: [l_suppkey#6, sum#13, isEmpty#14]

(14) Exchange
Input [3]: [l_suppkey#6, sum#13, isEmpty#14]
Arguments: hashpartitioning(l_suppkey#6, 5), ENSURE_REQUIREMENTS, [plan_id=2]

(15) ShuffleQueryStage
Output [3]: [l_suppkey#6, sum#13, isEmpty#14]
Arguments: X

(16) AQEShuffleRead
Input [3]: [l_suppkey#6, sum#13, isEmpty#14]
Arguments: coalesced

(17) HashAggregate [codegen id : 2]
Input [3]: [l_suppkey#6, sum#13, isEmpty#14]
Keys [1]: [l_suppkey#6]
Functions [1]: [sum((l_extendedprice#7 * (1 - l_discount#8)))]
Aggregate Attributes [1]: [sum((l_extendedprice#7 * (1 - l_discount#8)))#15]
Results [2]: [l_suppkey#6 AS supplier_no#16, sum((l_extendedprice#7 * (1 - l_discount#8)))#15 AS total_revenue#17]

(18) Filter [codegen id : 2]
Input [2]: [supplier_no#16, total_revenue#17]
Condition : (isnotnull(total_revenue#17) AND (total_revenue#17 = Subquery subquery#18, [id=#19]))

(19) ConvertToNative
Input [2]: [supplier_no#16, total_revenue#17]

(20) NativeSort
Input [2]: [supplier_no#16, total_revenue#17]
Arguments: [supplier_no#16 ASC NULLS FIRST], false

(21) NativeSortMergeJoin
Left keys [1]: [s_suppkey#1]
Right keys [1]: [supplier_no#16]
Join type: Inner
Join condition: None

(22) NativeProject
Output [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Input [6]: [#5#1, #2#2, #3#3, #4#4, supplier_no#16, total_revenue#17]

(23) NativeShuffleExchange
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: rangepartitioning(s_suppkey#1 ASC NULLS FIRST, 5), ENSURE_REQUIREMENTS, [plan_id=3]

(24) ShuffleQueryStage
Output [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: X

(25) AQEShuffleRead
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: local

(26) InputAdapter
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]

(27) Scan parquet 
Output [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(s_suppkey)]
ReadSchema: struct<s_suppkey:bigint,s_name:string,s_address:string,s_phone:string>

(28) Filter
Input [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Condition : isnotnull(s_suppkey#1)

(29) Exchange
Input [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Arguments: hashpartitioning(s_suppkey#1, 5), ENSURE_REQUIREMENTS, [plan_id=4]

(30) Sort
Input [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Arguments: [s_suppkey#1 ASC NULLS FIRST], false, 0

(31) Scan parquet 
Output [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01), IsNotNull(l_suppkey)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(32) Filter
Input [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]
Condition : (((isnotnull(l_shipdate#9) AND (l_shipdate#9 >= 1996-01-01)) AND (l_shipdate#9 < 1996-04-01)) AND isnotnull(l_suppkey#6))

(33) Project
Output [3]: [l_suppkey#6, l_extendedprice#7, l_discount#8]
Input [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]

(34) HashAggregate
Input [3]: [l_suppkey#6, l_extendedprice#7, l_discount#8]
Keys [1]: [l_suppkey#6]
Functions [1]: [partial_sum((l_extendedprice#7 * (1 - l_discount#8)))]
Aggregate Attributes [2]: [sum#11, isEmpty#12]
Results [3]: [l_suppkey#6, sum#13, isEmpty#14]

(35) Exchange
Input [3]: [l_suppkey#6, sum#13, isEmpty#14]
Arguments: hashpartitioning(l_suppkey#6, 5), ENSURE_REQUIREMENTS, [plan_id=5]

(36) HashAggregate
Input [3]: [l_suppkey#6, sum#13, isEmpty#14]
Keys [1]: [l_suppkey#6]
Functions [1]: [sum((l_extendedprice#7 * (1 - l_discount#8)))]
Aggregate Attributes [1]: [sum((l_extendedprice#7 * (1 - l_discount#8)))#15]
Results [2]: [l_suppkey#6 AS supplier_no#16, sum((l_extendedprice#7 * (1 - l_discount#8)))#15 AS total_revenue#17]

(37) Filter
Input [2]: [supplier_no#16, total_revenue#17]
Condition : (isnotnull(total_revenue#17) AND (total_revenue#17 = Subquery subquery#18, [id=#19]))

(38) Sort
Input [2]: [supplier_no#16, total_revenue#17]
Arguments: [supplier_no#16 ASC NULLS FIRST], false, 0

(39) SortMergeJoin
Left keys [1]: [s_suppkey#1]
Right keys [1]: [supplier_no#16]
Join type: Inner
Join condition: None

(40) Project
Output [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Input [6]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, supplier_no#16, total_revenue#17]

(41) Exchange
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: rangepartitioning(s_suppkey#1 ASC NULLS FIRST, 5), ENSURE_REQUIREMENTS, [plan_id=6]

(42) Sort
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: [s_suppkey#1 ASC NULLS FIRST], true, 0

(43) AdaptiveSparkPlan
Output [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: isFinalPlan=true

===== Subqueries =====

Subquery:1 Hosting operator id = 18 Hosting Expression = Subquery subquery#18, [id=#19]
AdaptiveSparkPlan (66)
+- == Final Plan ==
   * HashAggregate (56)
   +- ShuffleQueryStage (55), Statistics(sizeInBytes=32.0 B, rowCount=1)
      +- Exchange (54)
         +- * HashAggregate (53)
            +- * HashAggregate (52)
               +- AQEShuffleRead (51)
                  +- ShuffleQueryStage (50), Statistics(sizeInBytes=4.7 KiB, rowCount=100)
                     +- Exchange (49)
                        +- * HashAggregate (48)
                           +- NativeProject (47)
                              +- NativeFilter (46)
                                 +- InputAdapter (45)
                                    +- NativeParquetScan  (44)
+- == Initial Plan ==
   HashAggregate (65)
   +- Exchange (64)
      +- HashAggregate (63)
         +- HashAggregate (62)
            +- Exchange (61)
               +- HashAggregate (60)
                  +- Project (59)
                     +- Filter (58)
                        +- Scan parquet  (57)


(57) Scan parquet 
Output [4]: [l_suppkey#20, l_extendedprice#21, l_discount#22, l_shipdate#23]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(45) InputAdapter
Input [4]: [l_suppkey#20, l_extendedprice#21, l_discount#22, l_shipdate#23]
Arguments: [#24, #21, #22, #23]

(46) NativeFilter
Input [4]: [#24#20, #21#21, #22#22, #23#23]
Condition : ((isnotnull(l_shipdate#23) AND (l_shipdate#23 >= 1996-01-01)) AND (l_shipdate#23 < 1996-04-01))

(47) NativeProject
Output [3]: [l_suppkey#20, l_extendedprice#21, l_discount#22]
Input [4]: [#24#20, #21#21, #22#22, #23#23]

(48) HashAggregate [codegen id : 1]
Input [3]: [l_suppkey#20, l_extendedprice#21, l_discount#22]
Keys [1]: [l_suppkey#20]
Functions [1]: [partial_sum((l_extendedprice#21 * (1 - l_discount#22)))]
Aggregate Attributes [2]: [sum#25, isEmpty#26]
Results [3]: [l_suppkey#20, sum#27, isEmpty#28]

(49) Exchange
Input [3]: [l_suppkey#20, sum#27, isEmpty#28]
Arguments: hashpartitioning(l_suppkey#20, 5), ENSURE_REQUIREMENTS, [plan_id=7]

(50) ShuffleQueryStage
Output [3]: [l_suppkey#20, sum#27, isEmpty#28]
Arguments: X

(51) AQEShuffleRead
Input [3]: [l_suppkey#20, sum#27, isEmpty#28]
Arguments: coalesced

(52) HashAggregate [codegen id : 2]
Input [3]: [l_suppkey#20, sum#27, isEmpty#28]
Keys [1]: [l_suppkey#20]
Functions [1]: [sum((l_extendedprice#21 * (1 - l_discount#22)))]
Aggregate Attributes [1]: [sum((l_extendedprice#21 * (1 - l_discount#22)))#15]
Results [1]: [sum((l_extendedprice#21 * (1 - l_discount#22)))#15 AS total_revenue#29]

(53) HashAggregate [codegen id : 2]
Input [1]: [total_revenue#29]
Keys: []
Functions [1]: [partial_max(total_revenue#29)]
Aggregate Attributes [1]: [max#30]
Results [1]: [max#31]

(54) Exchange
Input [1]: [max#31]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=8]

(55) ShuffleQueryStage
Output [1]: [max#31]
Arguments: X

(56) HashAggregate [codegen id : 3]
Input [1]: [max#31]
Keys: []
Functions [1]: [max(total_revenue#29)]
Aggregate Attributes [1]: [max(total_revenue#29)#32]
Results [1]: [max(total_revenue#29)#32 AS max(total_revenue)#33]

(57) Scan parquet 
Output [4]: [l_suppkey#20, l_extendedprice#21, l_discount#22, l_shipdate#23]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(58) Filter
Input [4]: [l_suppkey#20, l_extendedprice#21, l_discount#22, l_shipdate#23]
Condition : ((isnotnull(l_shipdate#23) AND (l_shipdate#23 >= 1996-01-01)) AND (l_shipdate#23 < 1996-04-01))

(59) Project
Output [3]: [l_suppkey#20, l_extendedprice#21, l_discount#22]
Input [4]: [l_suppkey#20, l_extendedprice#21, l_discount#22, l_shipdate#23]

(60) HashAggregate
Input [3]: [l_suppkey#20, l_extendedprice#21, l_discount#22]
Keys [1]: [l_suppkey#20]
Functions [1]: [partial_sum((l_extendedprice#21 * (1 - l_discount#22)))]
Aggregate Attributes [2]: [sum#25, isEmpty#26]
Results [3]: [l_suppkey#20, sum#27, isEmpty#28]

(61) Exchange
Input [3]: [l_suppkey#20, sum#27, isEmpty#28]
Arguments: hashpartitioning(l_suppkey#20, 5), ENSURE_REQUIREMENTS, [plan_id=9]

(62) HashAggregate
Input [3]: [l_suppkey#20, sum#27, isEmpty#28]
Keys [1]: [l_suppkey#20]
Functions [1]: [sum((l_extendedprice#21 * (1 - l_discount#22)))]
Aggregate Attributes [1]: [sum((l_extendedprice#21 * (1 - l_discount#22)))#15]
Results [1]: [sum((l_extendedprice#21 * (1 - l_discount#22)))#15 AS total_revenue#29]

(63) HashAggregate
Input [1]: [total_revenue#29]
Keys: []
Functions [1]: [partial_max(total_revenue#29)]
Aggregate Attributes [1]: [max#30]
Results [1]: [max#31]

(64) Exchange
Input [1]: [max#31]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=10]

(65) HashAggregate
Input [1]: [max#31]
Keys: []
Functions [1]: [max(total_revenue#29)]
Aggregate Attributes [1]: [max(total_revenue#29)#32]
Results [1]: [max(total_revenue#29)#32 AS max(total_revenue)#33]

(66) AdaptiveSparkPlan
Output [1]: [max(total_revenue)#33]
Arguments: isFinalPlan=true


