== Physical Plan ==
AdaptiveSparkPlan (45)
+- == Final Plan ==
   InputAdapter (28)
   +- AQEShuffleRead (27)
      +- ShuffleQueryStage (26), Statistics(sizeInBytes=1256.0 B, rowCount=1)
         +- NativeShuffleExchange (25)
            +- NativeProject (24)
               +- NativeSortMergeJoin Inner (23)
                  :- NativeSort (8)
                  :  +- InputAdapter (7)
                  :     +- AQEShuffleRead (6)
                  :        +- ShuffleQueryStage (5), Statistics(sizeInBytes=9.6 KiB, rowCount=100)
                  :           +- NativeShuffleExchange (4)
                  :              +- NativeFilter (3)
                  :                 +- InputAdapter (2)
                  :                    +- NativeParquetScan  (1)
                  +- NativeSort (22)
                     +- NativeFilter (21)
                        +- NativeProject (20)
                           +- NativeHashAggregate (19)
                              +- InputAdapter (18)
                                 +- AQEShuffleRead (17)
                                    +- ShuffleQueryStage (16), Statistics(sizeInBytes=3.7 KiB, rowCount=100)
                                       +- NativeShuffleExchange (15)
                                          +- NativeHashAggregate (14)
                                             +- NativeProject (13)
                                                +- NativeProject (12)
                                                   +- NativeFilter (11)
                                                      +- InputAdapter (10)
                                                         +- NativeParquetScan  (9)
+- == Initial Plan ==
   Sort (44)
   +- Exchange (43)
      +- Project (42)
         +- SortMergeJoin Inner (41)
            :- Sort (32)
            :  +- Exchange (31)
            :     +- Filter (30)
            :        +- Scan parquet  (29)
            +- Sort (40)
               +- Filter (39)
                  +- HashAggregate (38)
                     +- Exchange (37)
                        +- HashAggregate (36)
                           +- Project (35)
                              +- Filter (34)
                                 +- Scan parquet  (33)


(29) Scan parquet 
Output [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(s_suppkey)]
ReadSchema: struct<s_suppkey:bigint,s_name:string,s_address:string,s_phone:string>

(2) InputAdapter
Input [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Arguments: [#5, #2, #3, #4]

(3) NativeFilter
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Condition : isnotnull(s_suppkey#1)

(4) NativeShuffleExchange
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Arguments: hashpartitioning(s_suppkey#1, 5), ENSURE_REQUIREMENTS, [plan_id=1]

(5) ShuffleQueryStage
Output [4]: [#5#1, #2#2, #3#3, #4#4]
Arguments: X

(6) AQEShuffleRead
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Arguments: coalesced

(7) InputAdapter
Input [4]: [#5#1, #2#2, #3#3, #4#4]

(8) NativeSort
Input [4]: [#5#1, #2#2, #3#3, #4#4]
Arguments: [s_suppkey#1 ASC NULLS FIRST], false

(33) Scan parquet 
Output [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01), IsNotNull(l_suppkey)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(10) InputAdapter
Input [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]
Arguments: [#10, #7, #8, #9]

(11) NativeFilter
Input [4]: [#10#6, #7#7, #8#8, #9#9]
Condition : (((isnotnull(l_shipdate#9) AND (l_shipdate#9 >= 1996-01-01)) AND (l_shipdate#9 < 1996-04-01)) AND isnotnull(l_suppkey#6))

(12) NativeProject
Output [3]: [l_suppkey#6, l_extendedprice#7, l_discount#8]
Input [4]: [#10#6, #7#7, #8#8, #9#9]

(13) NativeProject
Output [2]: [l_suppkey#6 AS l_suppkey#6, (l_extendedprice#7 * (1 - l_discount#8)) AS _c1#11]
Input [3]: [l_suppkey#6, l_extendedprice#7, l_discount#8]

(14) NativeHashAggregate
Input [2]: [l_suppkey#6, _c1#11]
Keys [1]: [l_suppkey#6]
Functions [1]: [partial_sum(_c1#11)]
Aggregate Attributes [2]: [sum#12, isEmpty#13]
Results [2]: [l_suppkey#6, #14#14]

(15) NativeShuffleExchange
Input [2]: [l_suppkey#6, #14#14]
Arguments: hashpartitioning(l_suppkey#6, 5), ENSURE_REQUIREMENTS, [plan_id=2]

(16) ShuffleQueryStage
Output [2]: [l_suppkey#6, #14#14]
Arguments: X

(17) AQEShuffleRead
Input [2]: [l_suppkey#6, #14#14]
Arguments: coalesced

(18) InputAdapter
Input [2]: [l_suppkey#6, #14#14]

(19) NativeHashAggregate
Input [2]: [l_suppkey#6, #14#14]
Keys [1]: [l_suppkey#6]
Functions [1]: [sum((l_extendedprice#7 * (1 - l_discount#8)))]
Aggregate Attributes [1]: [sum((l_extendedprice#7 * (1 - l_discount#8)))#15]
Results [2]: [l_suppkey#6, sum((l_extendedprice#7 * (1 - l_discount#8)))#15]

(20) NativeProject
Output [2]: [l_suppkey#6 AS supplier_no#16, sum((l_extendedprice#7 * (1 - l_discount#8)))#15 AS total_revenue#17]
Input [2]: [l_suppkey#6, sum((l_extendedprice#7 * (1 - l_discount#8)))#15]

(21) NativeFilter
Input [2]: [supplier_no#16, total_revenue#17]
Condition : (isnotnull(total_revenue#17) AND (total_revenue#17 = Subquery subquery#18, [id=#19]))

(22) NativeSort
Input [2]: [supplier_no#16, total_revenue#17]
Arguments: [supplier_no#16 ASC NULLS FIRST], false

(23) NativeSortMergeJoin
Left keys [1]: [s_suppkey#1]
Right keys [1]: [supplier_no#16]
Join type: Inner
Join condition: None

(24) NativeProject
Output [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Input [6]: [#5#1, #2#2, #3#3, #4#4, supplier_no#16, total_revenue#17]

(25) NativeShuffleExchange
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: rangepartitioning(s_suppkey#1 ASC NULLS FIRST, 5), ENSURE_REQUIREMENTS, [plan_id=3]

(26) ShuffleQueryStage
Output [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: X

(27) AQEShuffleRead
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: local

(28) InputAdapter
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]

(29) Scan parquet 
Output [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(s_suppkey)]
ReadSchema: struct<s_suppkey:bigint,s_name:string,s_address:string,s_phone:string>

(30) Filter
Input [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Condition : isnotnull(s_suppkey#1)

(31) Exchange
Input [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Arguments: hashpartitioning(s_suppkey#1, 5), ENSURE_REQUIREMENTS, [plan_id=4]

(32) Sort
Input [4]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4]
Arguments: [s_suppkey#1 ASC NULLS FIRST], false, 0

(33) Scan parquet 
Output [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01), IsNotNull(l_suppkey)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(34) Filter
Input [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]
Condition : (((isnotnull(l_shipdate#9) AND (l_shipdate#9 >= 1996-01-01)) AND (l_shipdate#9 < 1996-04-01)) AND isnotnull(l_suppkey#6))

(35) Project
Output [3]: [l_suppkey#6, l_extendedprice#7, l_discount#8]
Input [4]: [l_suppkey#6, l_extendedprice#7, l_discount#8, l_shipdate#9]

(36) HashAggregate
Input [3]: [l_suppkey#6, l_extendedprice#7, l_discount#8]
Keys [1]: [l_suppkey#6]
Functions [1]: [partial_sum((l_extendedprice#7 * (1 - l_discount#8)))]
Aggregate Attributes [2]: [sum#12, isEmpty#13]
Results [3]: [l_suppkey#6, sum#20, isEmpty#21]

(37) Exchange
Input [3]: [l_suppkey#6, sum#20, isEmpty#21]
Arguments: hashpartitioning(l_suppkey#6, 5), ENSURE_REQUIREMENTS, [plan_id=5]

(38) HashAggregate
Input [3]: [l_suppkey#6, sum#20, isEmpty#21]
Keys [1]: [l_suppkey#6]
Functions [1]: [sum((l_extendedprice#7 * (1 - l_discount#8)))]
Aggregate Attributes [1]: [sum((l_extendedprice#7 * (1 - l_discount#8)))#15]
Results [2]: [l_suppkey#6 AS supplier_no#16, sum((l_extendedprice#7 * (1 - l_discount#8)))#15 AS total_revenue#17]

(39) Filter
Input [2]: [supplier_no#16, total_revenue#17]
Condition : (isnotnull(total_revenue#17) AND (total_revenue#17 = Subquery subquery#18, [id=#19]))

(40) Sort
Input [2]: [supplier_no#16, total_revenue#17]
Arguments: [supplier_no#16 ASC NULLS FIRST], false, 0

(41) SortMergeJoin
Left keys [1]: [s_suppkey#1]
Right keys [1]: [supplier_no#16]
Join type: Inner
Join condition: None

(42) Project
Output [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Input [6]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, supplier_no#16, total_revenue#17]

(43) Exchange
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: rangepartitioning(s_suppkey#1 ASC NULLS FIRST, 5), ENSURE_REQUIREMENTS, [plan_id=6]

(44) Sort
Input [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: [s_suppkey#1 ASC NULLS FIRST], true, 0

(45) AdaptiveSparkPlan
Output [5]: [s_suppkey#1, s_name#2, s_address#3, s_phone#4, total_revenue#17]
Arguments: isFinalPlan=true

===== Subqueries =====

Subquery:1 Hosting operator id = 21 Hosting Expression = Subquery subquery#18, [id=#19]
AdaptiveSparkPlan (72)
+- == Final Plan ==
   NativeProject (62)
   +- NativeHashAggregate (61)
      +- ShuffleQueryStage (60), Statistics(sizeInBytes=360.0 B, rowCount=1)
         +- NativeShuffleExchange (59)
            +- NativeHashAggregate (58)
               +- NativeProject (57)
                  +- NativeHashAggregate (56)
                     +- InputAdapter (55)
                        +- AQEShuffleRead (54)
                           +- ShuffleQueryStage (53), Statistics(sizeInBytes=3.7 KiB, rowCount=100)
                              +- NativeShuffleExchange (52)
                                 +- NativeHashAggregate (51)
                                    +- NativeProject (50)
                                       +- NativeProject (49)
                                          +- NativeFilter (48)
                                             +- InputAdapter (47)
                                                +- NativeParquetScan  (46)
+- == Initial Plan ==
   HashAggregate (71)
   +- Exchange (70)
      +- HashAggregate (69)
         +- HashAggregate (68)
            +- Exchange (67)
               +- HashAggregate (66)
                  +- Project (65)
                     +- Filter (64)
                        +- Scan parquet  (63)


(63) Scan parquet 
Output [4]: [l_suppkey#22, l_extendedprice#23, l_discount#24, l_shipdate#25]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(47) InputAdapter
Input [4]: [l_suppkey#22, l_extendedprice#23, l_discount#24, l_shipdate#25]
Arguments: [#26, #23, #24, #25]

(48) NativeFilter
Input [4]: [#26#22, #23#23, #24#24, #25#25]
Condition : ((isnotnull(l_shipdate#25) AND (l_shipdate#25 >= 1996-01-01)) AND (l_shipdate#25 < 1996-04-01))

(49) NativeProject
Output [3]: [l_suppkey#22, l_extendedprice#23, l_discount#24]
Input [4]: [#26#22, #23#23, #24#24, #25#25]

(50) NativeProject
Output [2]: [l_suppkey#22 AS l_suppkey#22, (l_extendedprice#23 * (1 - l_discount#24)) AS _c1#27]
Input [3]: [l_suppkey#22, l_extendedprice#23, l_discount#24]

(51) NativeHashAggregate
Input [2]: [l_suppkey#22, _c1#27]
Keys [1]: [l_suppkey#22]
Functions [1]: [partial_sum(_c1#27)]
Aggregate Attributes [2]: [sum#28, isEmpty#29]
Results [2]: [l_suppkey#22, #14#14]

(52) NativeShuffleExchange
Input [2]: [l_suppkey#22, #14#14]
Arguments: hashpartitioning(l_suppkey#22, 5), ENSURE_REQUIREMENTS, [plan_id=7]

(53) ShuffleQueryStage
Output [2]: [l_suppkey#22, #14#14]
Arguments: X

(54) AQEShuffleRead
Input [2]: [l_suppkey#22, #14#14]
Arguments: coalesced

(55) InputAdapter
Input [2]: [l_suppkey#22, #14#14]

(56) NativeHashAggregate
Input [2]: [l_suppkey#22, #14#14]
Keys [1]: [l_suppkey#22]
Functions [1]: [sum((l_extendedprice#23 * (1 - l_discount#24)))]
Aggregate Attributes [1]: [sum((l_extendedprice#23 * (1 - l_discount#24)))#15]
Results [2]: [l_suppkey#22, sum((l_extendedprice#23 * (1 - l_discount#24)))#15]

(57) NativeProject
Output [1]: [sum((l_extendedprice#23 * (1 - l_discount#24)))#15 AS total_revenue#30]
Input [2]: [l_suppkey#22, sum((l_extendedprice#23 * (1 - l_discount#24)))#15]

(58) NativeHashAggregate
Input [1]: [total_revenue#30]
Keys: []
Functions [1]: [partial_max(total_revenue#30)]
Aggregate Attributes [1]: [max#31]
Results [1]: [#14#14]

(59) NativeShuffleExchange
Input [1]: [#14#14]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=8]

(60) ShuffleQueryStage
Output [1]: [#14#14]
Arguments: X

(61) NativeHashAggregate
Input [1]: [#14#14]
Keys: []
Functions [1]: [max(total_revenue#30)]
Aggregate Attributes [1]: [max(total_revenue#30)#32]
Results [1]: [max(total_revenue#30)#32]

(62) NativeProject
Output [1]: [max(total_revenue#30)#32 AS max(total_revenue)#33]
Input [1]: [max(total_revenue#30)#32]

(63) Scan parquet 
Output [4]: [l_suppkey#22, l_extendedprice#23, l_discount#24, l_shipdate#25]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_shipdate), GreaterThanOrEqual(l_shipdate,1996-01-01), LessThan(l_shipdate,1996-04-01)]
ReadSchema: struct<l_suppkey:bigint,l_extendedprice:decimal(12,2),l_discount:decimal(12,2),l_shipdate:date>

(64) Filter
Input [4]: [l_suppkey#22, l_extendedprice#23, l_discount#24, l_shipdate#25]
Condition : ((isnotnull(l_shipdate#25) AND (l_shipdate#25 >= 1996-01-01)) AND (l_shipdate#25 < 1996-04-01))

(65) Project
Output [3]: [l_suppkey#22, l_extendedprice#23, l_discount#24]
Input [4]: [l_suppkey#22, l_extendedprice#23, l_discount#24, l_shipdate#25]

(66) HashAggregate
Input [3]: [l_suppkey#22, l_extendedprice#23, l_discount#24]
Keys [1]: [l_suppkey#22]
Functions [1]: [partial_sum((l_extendedprice#23 * (1 - l_discount#24)))]
Aggregate Attributes [2]: [sum#28, isEmpty#29]
Results [3]: [l_suppkey#22, sum#34, isEmpty#35]

(67) Exchange
Input [3]: [l_suppkey#22, sum#34, isEmpty#35]
Arguments: hashpartitioning(l_suppkey#22, 5), ENSURE_REQUIREMENTS, [plan_id=9]

(68) HashAggregate
Input [3]: [l_suppkey#22, sum#34, isEmpty#35]
Keys [1]: [l_suppkey#22]
Functions [1]: [sum((l_extendedprice#23 * (1 - l_discount#24)))]
Aggregate Attributes [1]: [sum((l_extendedprice#23 * (1 - l_discount#24)))#15]
Results [1]: [sum((l_extendedprice#23 * (1 - l_discount#24)))#15 AS total_revenue#30]

(69) HashAggregate
Input [1]: [total_revenue#30]
Keys: []
Functions [1]: [partial_max(total_revenue#30)]
Aggregate Attributes [1]: [max#31]
Results [1]: [max#36]

(70) Exchange
Input [1]: [max#36]
Arguments: SinglePartition, ENSURE_REQUIREMENTS, [plan_id=10]

(71) HashAggregate
Input [1]: [max#36]
Keys: []
Functions [1]: [max(total_revenue#30)]
Aggregate Attributes [1]: [max(total_revenue#30)#32]
Results [1]: [max(total_revenue#30)#32 AS max(total_revenue)#33]

(72) AdaptiveSparkPlan
Output [1]: [max(total_revenue)#33]
Arguments: isFinalPlan=true


