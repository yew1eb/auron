== Physical Plan ==
AdaptiveSparkPlan (50)
+- == Final Plan ==
   NativeSort (32)
   +- InputAdapter (31)
      +- AQEShuffleRead (30)
         +- ShuffleQueryStage (29), Statistics(sizeInBytes=584.0 B, rowCount=5)
            +- NativeShuffleExchange (28)
               +- NativeProject (27)
                  +- NativeHashAggregate (26)
                     +- InputAdapter (25)
                        +- AQEShuffleRead (24)
                           +- ShuffleQueryStage (23), Statistics(sizeInBytes=696.0 B, rowCount=5)
                              +- NativeShuffleExchange (22)
                                 +- NativeHashAggregate (21)
                                    +- NativeProject (20)
                                       +- NativeSortMergeJoin LeftSemi (19)
                                          :- NativeSort (9)
                                          :  +- InputAdapter (8)
                                          :     +- AQEShuffleRead (7)
                                          :        +- ShuffleQueryStage (6), Statistics(sizeInBytes=12.0 KiB, rowCount=582)
                                          :           +- NativeShuffleExchange (5)
                                          :              +- NativeProject (4)
                                          :                 +- NativeFilter (3)
                                          :                    +- InputAdapter (2)
                                          :                       +- NativeParquetScan  (1)
                                          +- NativeSort (18)
                                             +- InputAdapter (17)
                                                +- AQEShuffleRead (16)
                                                   +- ShuffleQueryStage (15), Statistics(sizeInBytes=297.5 KiB, rowCount=3.79E+4)
                                                      +- NativeShuffleExchange (14)
                                                         +- NativeProject (13)
                                                            +- NativeFilter (12)
                                                               +- InputAdapter (11)
                                                                  +- NativeParquetScan  (10)
+- == Initial Plan ==
   Sort (49)
   +- Exchange (48)
      +- HashAggregate (47)
         +- Exchange (46)
            +- HashAggregate (45)
               +- Project (44)
                  +- SortMergeJoin LeftSemi (43)
                     :- Sort (37)
                     :  +- Exchange (36)
                     :     +- Project (35)
                     :        +- Filter (34)
                     :           +- Scan parquet  (33)
                     +- Sort (42)
                        +- Exchange (41)
                           +- Project (40)
                              +- Filter (39)
                                 +- Scan parquet  (38)


(33) Scan parquet 
Output [3]: [o_orderkey#1, o_orderdate#2, o_orderpriority#3]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(o_orderdate), GreaterThanOrEqual(o_orderdate,1993-07-01), LessThan(o_orderdate,1993-10-01)]
ReadSchema: struct<o_orderkey:bigint,o_orderdate:date,o_orderpriority:string>

(2) InputAdapter
Input [3]: [o_orderkey#1, o_orderdate#2, o_orderpriority#3]
Arguments: [#4, #2, #3]

(3) NativeFilter
Input [3]: [#4#1, #2#2, #3#3]
Condition : ((isnotnull(o_orderdate#2) AND (o_orderdate#2 >= 1993-07-01)) AND (o_orderdate#2 < 1993-10-01))

(4) NativeProject
Output [2]: [o_orderkey#1, o_orderpriority#3]
Input [3]: [#4#1, #2#2, #3#3]

(5) NativeShuffleExchange
Input [2]: [o_orderkey#1, o_orderpriority#3]
Arguments: hashpartitioning(o_orderkey#1, 5), ENSURE_REQUIREMENTS, [plan_id=1]

(6) ShuffleQueryStage
Output [2]: [o_orderkey#1, o_orderpriority#3]
Arguments: X

(7) AQEShuffleRead
Input [2]: [o_orderkey#1, o_orderpriority#3]
Arguments: coalesced

(8) InputAdapter
Input [2]: [o_orderkey#1, o_orderpriority#3]

(9) NativeSort
Input [2]: [o_orderkey#1, o_orderpriority#3]
Arguments: [o_orderkey#1 ASC NULLS FIRST], false

(38) Scan parquet 
Output [3]: [l_orderkey#5, l_commitdate#6, l_receiptdate#7]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_commitdate), IsNotNull(l_receiptdate)]
ReadSchema: struct<l_orderkey:bigint,l_commitdate:date,l_receiptdate:date>

(11) InputAdapter
Input [3]: [l_orderkey#5, l_commitdate#6, l_receiptdate#7]
Arguments: [#8, #6, #7]

(12) NativeFilter
Input [3]: [#8#5, #6#6, #7#7]
Condition : ((isnotnull(l_commitdate#6) AND isnotnull(l_receiptdate#7)) AND (l_commitdate#6 < l_receiptdate#7))

(13) NativeProject
Output [1]: [l_orderkey#5]
Input [3]: [#8#5, #6#6, #7#7]

(14) NativeShuffleExchange
Input [1]: [l_orderkey#5]
Arguments: hashpartitioning(l_orderkey#5, 5), ENSURE_REQUIREMENTS, [plan_id=2]

(15) ShuffleQueryStage
Output [1]: [l_orderkey#5]
Arguments: X

(16) AQEShuffleRead
Input [1]: [l_orderkey#5]
Arguments: coalesced

(17) InputAdapter
Input [1]: [l_orderkey#5]

(18) NativeSort
Input [1]: [l_orderkey#5]
Arguments: [l_orderkey#5 ASC NULLS FIRST], false

(19) NativeSortMergeJoin
Left keys [1]: [o_orderkey#1]
Right keys [1]: [l_orderkey#5]
Join type: LeftSemi
Join condition: None

(20) NativeProject
Output [1]: [o_orderpriority#3]
Input [2]: [o_orderkey#1, o_orderpriority#3]

(21) NativeHashAggregate
Input [1]: [o_orderpriority#3]
Keys [1]: [o_orderpriority#3]
Functions [1]: [partial_count(1)]
Aggregate Attributes [1]: [count#9]
Results [2]: [o_orderpriority#3, #10#10]

(22) NativeShuffleExchange
Input [2]: [o_orderpriority#3, #10#10]
Arguments: hashpartitioning(o_orderpriority#3, 5), ENSURE_REQUIREMENTS, [plan_id=3]

(23) ShuffleQueryStage
Output [2]: [o_orderpriority#3, #10#10]
Arguments: X

(24) AQEShuffleRead
Input [2]: [o_orderpriority#3, #10#10]
Arguments: coalesced

(25) InputAdapter
Input [2]: [o_orderpriority#3, #10#10]

(26) NativeHashAggregate
Input [2]: [o_orderpriority#3, #10#10]
Keys [1]: [o_orderpriority#3]
Functions [1]: [count(1)]
Aggregate Attributes [1]: [count(1)#11]
Results [2]: [o_orderpriority#3, count(1)#11]

(27) NativeProject
Output [2]: [o_orderpriority#3, count(1)#11 AS order_count#12]
Input [2]: [o_orderpriority#3, count(1)#11]

(28) NativeShuffleExchange
Input [2]: [o_orderpriority#3, order_count#12]
Arguments: rangepartitioning(o_orderpriority#3 ASC NULLS FIRST, 5), ENSURE_REQUIREMENTS, [plan_id=4]

(29) ShuffleQueryStage
Output [2]: [o_orderpriority#3, order_count#12]
Arguments: X

(30) AQEShuffleRead
Input [2]: [o_orderpriority#3, order_count#12]
Arguments: coalesced

(31) InputAdapter
Input [2]: [o_orderpriority#3, order_count#12]

(32) NativeSort
Input [2]: [o_orderpriority#3, order_count#12]
Arguments: [o_orderpriority#3 ASC NULLS FIRST], true

(33) Scan parquet 
Output [3]: [o_orderkey#1, o_orderdate#2, o_orderpriority#3]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(o_orderdate), GreaterThanOrEqual(o_orderdate,1993-07-01), LessThan(o_orderdate,1993-10-01)]
ReadSchema: struct<o_orderkey:bigint,o_orderdate:date,o_orderpriority:string>

(34) Filter
Input [3]: [o_orderkey#1, o_orderdate#2, o_orderpriority#3]
Condition : ((isnotnull(o_orderdate#2) AND (o_orderdate#2 >= 1993-07-01)) AND (o_orderdate#2 < 1993-10-01))

(35) Project
Output [2]: [o_orderkey#1, o_orderpriority#3]
Input [3]: [o_orderkey#1, o_orderdate#2, o_orderpriority#3]

(36) Exchange
Input [2]: [o_orderkey#1, o_orderpriority#3]
Arguments: hashpartitioning(o_orderkey#1, 5), ENSURE_REQUIREMENTS, [plan_id=5]

(37) Sort
Input [2]: [o_orderkey#1, o_orderpriority#3]
Arguments: [o_orderkey#1 ASC NULLS FIRST], false, 0

(38) Scan parquet 
Output [3]: [l_orderkey#5, l_commitdate#6, l_receiptdate#7]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(l_commitdate), IsNotNull(l_receiptdate)]
ReadSchema: struct<l_orderkey:bigint,l_commitdate:date,l_receiptdate:date>

(39) Filter
Input [3]: [l_orderkey#5, l_commitdate#6, l_receiptdate#7]
Condition : ((isnotnull(l_commitdate#6) AND isnotnull(l_receiptdate#7)) AND (l_commitdate#6 < l_receiptdate#7))

(40) Project
Output [1]: [l_orderkey#5]
Input [3]: [l_orderkey#5, l_commitdate#6, l_receiptdate#7]

(41) Exchange
Input [1]: [l_orderkey#5]
Arguments: hashpartitioning(l_orderkey#5, 5), ENSURE_REQUIREMENTS, [plan_id=6]

(42) Sort
Input [1]: [l_orderkey#5]
Arguments: [l_orderkey#5 ASC NULLS FIRST], false, 0

(43) SortMergeJoin
Left keys [1]: [o_orderkey#1]
Right keys [1]: [l_orderkey#5]
Join type: LeftSemi
Join condition: None

(44) Project
Output [1]: [o_orderpriority#3]
Input [2]: [o_orderkey#1, o_orderpriority#3]

(45) HashAggregate
Input [1]: [o_orderpriority#3]
Keys [1]: [o_orderpriority#3]
Functions [1]: [partial_count(1)]
Aggregate Attributes [1]: [count#9]
Results [2]: [o_orderpriority#3, count#13]

(46) Exchange
Input [2]: [o_orderpriority#3, count#13]
Arguments: hashpartitioning(o_orderpriority#3, 5), ENSURE_REQUIREMENTS, [plan_id=7]

(47) HashAggregate
Input [2]: [o_orderpriority#3, count#13]
Keys [1]: [o_orderpriority#3]
Functions [1]: [count(1)]
Aggregate Attributes [1]: [count(1)#11]
Results [2]: [o_orderpriority#3, count(1)#11 AS order_count#12]

(48) Exchange
Input [2]: [o_orderpriority#3, order_count#12]
Arguments: rangepartitioning(o_orderpriority#3 ASC NULLS FIRST, 5), ENSURE_REQUIREMENTS, [plan_id=8]

(49) Sort
Input [2]: [o_orderpriority#3, order_count#12]
Arguments: [o_orderpriority#3 ASC NULLS FIRST], true, 0

(50) AdaptiveSparkPlan
Output [2]: [o_orderpriority#3, order_count#12]
Arguments: isFinalPlan=true

