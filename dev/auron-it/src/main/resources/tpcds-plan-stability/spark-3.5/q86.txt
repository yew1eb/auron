== Physical Plan ==
AdaptiveSparkPlan (80)
+- == Final Plan ==
   NativeTakeOrdered (51)
   +- NativeProject (50)
      +- NativeWindow (49)
         +- NativeSort (48)
            +- InputAdapter (47)
               +- AQEShuffleRead (46)
                  +- ShuffleQueryStage (45), Statistics(X)
                     +- NativeShuffleExchange (44)
                        +- NativeProject (43)
                           +- NativeHashAggregate (42)
                              +- InputAdapter (41)
                                 +- AQEShuffleRead (40)
                                    +- ShuffleQueryStage (39), Statistics(X)
                                       +- NativeShuffleExchange (38)
                                          +- NativeHashAggregate (37)
                                             +- NativeProject (36)
                                                +- NativeExpand (35)
                                                   +- NativeProject (34)
                                                      +- NativeSortMergeJoin Inner (33)
                                                         :- NativeSort (24)
                                                         :  +- InputAdapter (23)
                                                         :     +- AQEShuffleRead (22)
                                                         :        +- ShuffleQueryStage (21), Statistics(X)
                                                         :           +- NativeShuffleExchange (20)
                                                         :              +- NativeProject (19)
                                                         :                 +- NativeSortMergeJoin Inner (18)
                                                         :                    :- NativeSort (8)
                                                         :                    :  +- InputAdapter (7)
                                                         :                    :     +- AQEShuffleRead (6)
                                                         :                    :        +- ShuffleQueryStage (5), Statistics(X)
                                                         :                    :           +- NativeShuffleExchange (4)
                                                         :                    :              +- NativeFilter (3)
                                                         :                    :                 +- InputAdapter (2)
                                                         :                    :                    +- NativeParquetScan  (1)
                                                         :                    +- NativeSort (17)
                                                         :                       +- InputAdapter (16)
                                                         :                          +- AQEShuffleRead (15)
                                                         :                             +- ShuffleQueryStage (14), Statistics(X)
                                                         :                                +- NativeShuffleExchange (13)
                                                         :                                   +- NativeProject (12)
                                                         :                                      +- NativeFilter (11)
                                                         :                                         +- InputAdapter (10)
                                                         :                                            +- NativeParquetScan  (9)
                                                         +- NativeSort (32)
                                                            +- InputAdapter (31)
                                                               +- AQEShuffleRead (30)
                                                                  +- ShuffleQueryStage (29), Statistics(X)
                                                                     +- NativeShuffleExchange (28)
                                                                        +- NativeFilter (27)
                                                                           +- InputAdapter (26)
                                                                              +- NativeParquetScan  (25)
+- == Initial Plan ==
   TakeOrderedAndProject (79)
   +- Project (78)
      +- Window (77)
         +- Sort (76)
            +- Exchange (75)
               +- HashAggregate (74)
                  +- Exchange (73)
                     +- HashAggregate (72)
                        +- Expand (71)
                           +- Project (70)
                              +- SortMergeJoin Inner (69)
                                 :- Sort (64)
                                 :  +- Exchange (63)
                                 :     +- Project (62)
                                 :        +- SortMergeJoin Inner (61)
                                 :           :- Sort (55)
                                 :           :  +- Exchange (54)
                                 :           :     +- Filter (53)
                                 :           :        +- Scan parquet (52)
                                 :           +- Sort (60)
                                 :              +- Exchange (59)
                                 :                 +- Project (58)
                                 :                    +- Filter (57)
                                 :                       +- Scan parquet (56)
                                 +- Sort (68)
                                    +- Exchange (67)
                                       +- Filter (66)
                                          +- Scan parquet (65)


(52) Scan parquet
Output [3]: [ws_sold_date_sk#1, ws_item_sk#2, ws_net_paid#3]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(ws_sold_date_sk), IsNotNull(ws_item_sk)]
ReadSchema: struct<ws_sold_date_sk:int,ws_item_sk:int,ws_net_paid:decimal(7,2)>

(2) InputAdapter
Input [3]: [ws_sold_date_sk#1, ws_item_sk#2, ws_net_paid#3]
Arguments: [#1, #2, #3]

(3) NativeFilter
Input [3]: [#1#1, #2#2, #3#3]
Condition : (isnotnull(ws_sold_date_sk#1) AND isnotnull(ws_item_sk#2))

(4) NativeShuffleExchange
Input [3]: [#1#1, #2#2, #3#3]
Arguments: hashpartitioning(ws_sold_date_sk#1, 100), ENSURE_REQUIREMENTS, [plan_id=1]

(5) ShuffleQueryStage
Output [3]: [#1#1, #2#2, #3#3]
Arguments: X

(6) AQEShuffleRead
Input [3]: [#1#1, #2#2, #3#3]
Arguments: coalesced

(7) InputAdapter
Input [3]: [#1#1, #2#2, #3#3]

(8) NativeSort
Input [3]: [#1#1, #2#2, #3#3]
Arguments: [ws_sold_date_sk#1 ASC NULLS FIRST], false

(56) Scan parquet
Output [2]: [d_date_sk#4, d_month_seq#5]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(d_month_seq), GreaterThanOrEqual(d_month_seq,1200), LessThanOrEqual(d_month_seq,1211), IsNotNull(d_date_sk)]
ReadSchema: struct<d_date_sk:int,d_month_seq:int>

(10) InputAdapter
Input [2]: [d_date_sk#4, d_month_seq#5]
Arguments: [#4, #5]

(11) NativeFilter
Input [2]: [#4#4, #5#5]
Condition : (((isnotnull(d_month_seq#5) AND (d_month_seq#5 >= 1200)) AND (d_month_seq#5 <= 1211)) AND isnotnull(d_date_sk#4))

(12) NativeProject
Output [1]: [d_date_sk#4]
Input [2]: [#4#4, #5#5]

(13) NativeShuffleExchange
Input [1]: [d_date_sk#4]
Arguments: hashpartitioning(d_date_sk#4, 100), ENSURE_REQUIREMENTS, [plan_id=2]

(14) ShuffleQueryStage
Output [1]: [d_date_sk#4]
Arguments: X

(15) AQEShuffleRead
Input [1]: [d_date_sk#4]
Arguments: coalesced

(16) InputAdapter
Input [1]: [d_date_sk#4]

(17) NativeSort
Input [1]: [d_date_sk#4]
Arguments: [d_date_sk#4 ASC NULLS FIRST], false

(18) NativeSortMergeJoin
Left keys [1]: [ws_sold_date_sk#1]
Right keys [1]: [d_date_sk#4]
Join type: Inner
Join condition: None

(19) NativeProject
Output [2]: [ws_item_sk#2, ws_net_paid#3]
Input [4]: [#1#1, #2#2, #3#3, d_date_sk#4]

(20) NativeShuffleExchange
Input [2]: [ws_item_sk#2, ws_net_paid#3]
Arguments: hashpartitioning(ws_item_sk#2, 100), ENSURE_REQUIREMENTS, [plan_id=3]

(21) ShuffleQueryStage
Output [2]: [ws_item_sk#2, ws_net_paid#3]
Arguments: X

(22) AQEShuffleRead
Input [2]: [ws_item_sk#2, ws_net_paid#3]
Arguments: coalesced

(23) InputAdapter
Input [2]: [ws_item_sk#2, ws_net_paid#3]

(24) NativeSort
Input [2]: [ws_item_sk#2, ws_net_paid#3]
Arguments: [ws_item_sk#2 ASC NULLS FIRST], false

(65) Scan parquet
Output [3]: [i_item_sk#6, i_class#7, i_category#8]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(i_item_sk)]
ReadSchema: struct<i_item_sk:int,i_class:string,i_category:string>

(26) InputAdapter
Input [3]: [i_item_sk#6, i_class#7, i_category#8]
Arguments: [#6, #7, #8]

(27) NativeFilter
Input [3]: [#6#6, #7#7, #8#8]
Condition : isnotnull(i_item_sk#6)

(28) NativeShuffleExchange
Input [3]: [#6#6, #7#7, #8#8]
Arguments: hashpartitioning(i_item_sk#6, 100), ENSURE_REQUIREMENTS, [plan_id=4]

(29) ShuffleQueryStage
Output [3]: [#6#6, #7#7, #8#8]
Arguments: X

(30) AQEShuffleRead
Input [3]: [#6#6, #7#7, #8#8]
Arguments: coalesced

(31) InputAdapter
Input [3]: [#6#6, #7#7, #8#8]

(32) NativeSort
Input [3]: [#6#6, #7#7, #8#8]
Arguments: [i_item_sk#6 ASC NULLS FIRST], false

(33) NativeSortMergeJoin
Left keys [1]: [ws_item_sk#2]
Right keys [1]: [i_item_sk#6]
Join type: Inner
Join condition: None

(34) NativeProject
Output [3]: [ws_net_paid#3, i_category#8, i_class#7]
Input [5]: [ws_item_sk#2, ws_net_paid#3, #6#6, #7#7, #8#8]

(35) NativeExpand
Input [3]: [ws_net_paid#3, i_category#8, i_class#7]
Arguments: [[ws_net_paid#3, i_category#8, i_class#7, 0], [ws_net_paid#3, i_category#8, null, 1], [ws_net_paid#3, null, null, 3]], [ws_net_paid#3, i_category#9, i_class#10, spark_grouping_id#11]

(36) NativeProject
Output [4]: [i_category#9 AS i_category#9, i_class#10 AS i_class#10, spark_grouping_id#11 AS spark_grouping_id#11, UnscaledValue(ws_net_paid#3) AS _c3#12]
Input [4]: [ws_net_paid#3, i_category#9, i_class#10, spark_grouping_id#11]

(37) NativeHashAggregate
Input [4]: [i_category#9, i_class#10, spark_grouping_id#11, _c3#12]
Keys [3]: [i_category#9, i_class#10, spark_grouping_id#11]
Functions [1]: [partial_sum(_c3#12)]
Aggregate Attributes [1]: [sum#13]
Results [4]: [i_category#9, i_class#10, spark_grouping_id#11, #14]

(38) NativeShuffleExchange
Input [4]: [i_category#9, i_class#10, spark_grouping_id#11, #14]
Arguments: hashpartitioning(i_category#9, i_class#10, spark_grouping_id#11, 100), ENSURE_REQUIREMENTS, [plan_id=5]

(39) ShuffleQueryStage
Output [4]: [i_category#9, i_class#10, spark_grouping_id#11, #14]
Arguments: X

(40) AQEShuffleRead
Input [4]: [i_category#9, i_class#10, spark_grouping_id#11, #14]
Arguments: coalesced

(41) InputAdapter
Input [4]: [i_category#9, i_class#10, spark_grouping_id#11, #14]

(42) NativeHashAggregate
Input [4]: [i_category#9, i_class#10, spark_grouping_id#11, #14]
Keys [3]: [i_category#9, i_class#10, spark_grouping_id#11]
Functions [1]: [sum(UnscaledValue(ws_net_paid#3))]
Aggregate Attributes [1]: [sum(UnscaledValue(ws_net_paid#3))#15]
Results [4]: [i_category#9, i_class#10, spark_grouping_id#11, sum(UnscaledValue(ws_net_paid#3))#15]

(43) NativeProject
Output [7]: [MakeDecimal(sum(UnscaledValue(ws_net_paid#3))#15,17,2) AS total_sum#16, i_category#9, i_class#10, (cast((shiftright(spark_grouping_id#11, 1) & 1) as tinyint) + cast((shiftright(spark_grouping_id#11, 0) & 1) as tinyint)) AS lochierarchy#17, MakeDecimal(sum(UnscaledValue(ws_net_paid#3))#15,17,2) AS _w0#18, (cast((shiftright(spark_grouping_id#11, 1) & 1) as tinyint) + cast((shiftright(spark_grouping_id#11, 0) & 1) as tinyint)) AS _w1#19, CASE WHEN (cast((shiftright(spark_grouping_id#11, 0) & 1) as tinyint) = 0) THEN i_category#9 END AS _w2#20]
Input [4]: [i_category#9, i_class#10, spark_grouping_id#11, sum(UnscaledValue(ws_net_paid#3))#15]

(44) NativeShuffleExchange
Input [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]
Arguments: hashpartitioning(_w1#19, _w2#20, 100), ENSURE_REQUIREMENTS, [plan_id=6]

(45) ShuffleQueryStage
Output [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]
Arguments: X

(46) AQEShuffleRead
Input [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]
Arguments: coalesced

(47) InputAdapter
Input [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]

(48) NativeSort
Input [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]
Arguments: [_w1#19 ASC NULLS FIRST, _w2#20 ASC NULLS FIRST, _w0#18 DESC NULLS LAST], false

(49) NativeWindow
Input [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]
Arguments: [rank(_w0#18) windowspecdefinition(_w1#19, _w2#20, _w0#18 DESC NULLS LAST, specifiedwindowframe(RowFrame, unboundedpreceding$(), currentrow$())) AS rank_within_parent#21], [_w1#19, _w2#20], [_w0#18 DESC NULLS LAST]

(50) NativeProject
Output [5]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, rank_within_parent#21]
Input [8]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20, rank_within_parent#21]

(51) NativeTakeOrdered
Input [5]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, rank_within_parent#21]
Arguments: X, [lochierarchy#17 DESC NULLS LAST, CASE WHEN (lochierarchy#17 = 0) THEN i_category#9 END ASC NULLS FIRST, rank_within_parent#21 ASC NULLS FIRST]

(52) Scan parquet
Output [3]: [ws_sold_date_sk#1, ws_item_sk#2, ws_net_paid#3]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(ws_sold_date_sk), IsNotNull(ws_item_sk)]
ReadSchema: struct<ws_sold_date_sk:int,ws_item_sk:int,ws_net_paid:decimal(7,2)>

(53) Filter
Input [3]: [ws_sold_date_sk#1, ws_item_sk#2, ws_net_paid#3]
Condition : (isnotnull(ws_sold_date_sk#1) AND isnotnull(ws_item_sk#2))

(54) Exchange
Input [3]: [ws_sold_date_sk#1, ws_item_sk#2, ws_net_paid#3]
Arguments: hashpartitioning(ws_sold_date_sk#1, 100), ENSURE_REQUIREMENTS, [plan_id=7]

(55) Sort
Input [3]: [ws_sold_date_sk#1, ws_item_sk#2, ws_net_paid#3]
Arguments: [ws_sold_date_sk#1 ASC NULLS FIRST], false, 0

(56) Scan parquet
Output [2]: [d_date_sk#4, d_month_seq#5]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(d_month_seq), GreaterThanOrEqual(d_month_seq,1200), LessThanOrEqual(d_month_seq,1211), IsNotNull(d_date_sk)]
ReadSchema: struct<d_date_sk:int,d_month_seq:int>

(57) Filter
Input [2]: [d_date_sk#4, d_month_seq#5]
Condition : (((isnotnull(d_month_seq#5) AND (d_month_seq#5 >= 1200)) AND (d_month_seq#5 <= 1211)) AND isnotnull(d_date_sk#4))

(58) Project
Output [1]: [d_date_sk#4]
Input [2]: [d_date_sk#4, d_month_seq#5]

(59) Exchange
Input [1]: [d_date_sk#4]
Arguments: hashpartitioning(d_date_sk#4, 100), ENSURE_REQUIREMENTS, [plan_id=8]

(60) Sort
Input [1]: [d_date_sk#4]
Arguments: [d_date_sk#4 ASC NULLS FIRST], false, 0

(61) SortMergeJoin
Left keys [1]: [ws_sold_date_sk#1]
Right keys [1]: [d_date_sk#4]
Join type: Inner
Join condition: None

(62) Project
Output [2]: [ws_item_sk#2, ws_net_paid#3]
Input [4]: [ws_sold_date_sk#1, ws_item_sk#2, ws_net_paid#3, d_date_sk#4]

(63) Exchange
Input [2]: [ws_item_sk#2, ws_net_paid#3]
Arguments: hashpartitioning(ws_item_sk#2, 100), ENSURE_REQUIREMENTS, [plan_id=9]

(64) Sort
Input [2]: [ws_item_sk#2, ws_net_paid#3]
Arguments: [ws_item_sk#2 ASC NULLS FIRST], false, 0

(65) Scan parquet
Output [3]: [i_item_sk#6, i_class#7, i_category#8]
Batched: true
Location: InMemoryFileIndex [file:/<warehouse_dir>]
PushedFilters: [IsNotNull(i_item_sk)]
ReadSchema: struct<i_item_sk:int,i_class:string,i_category:string>

(66) Filter
Input [3]: [i_item_sk#6, i_class#7, i_category#8]
Condition : isnotnull(i_item_sk#6)

(67) Exchange
Input [3]: [i_item_sk#6, i_class#7, i_category#8]
Arguments: hashpartitioning(i_item_sk#6, 100), ENSURE_REQUIREMENTS, [plan_id=10]

(68) Sort
Input [3]: [i_item_sk#6, i_class#7, i_category#8]
Arguments: [i_item_sk#6 ASC NULLS FIRST], false, 0

(69) SortMergeJoin
Left keys [1]: [ws_item_sk#2]
Right keys [1]: [i_item_sk#6]
Join type: Inner
Join condition: None

(70) Project
Output [3]: [ws_net_paid#3, i_category#8, i_class#7]
Input [5]: [ws_item_sk#2, ws_net_paid#3, i_item_sk#6, i_class#7, i_category#8]

(71) Expand
Input [3]: [ws_net_paid#3, i_category#8, i_class#7]
Arguments: [[ws_net_paid#3, i_category#8, i_class#7, 0], [ws_net_paid#3, i_category#8, null, 1], [ws_net_paid#3, null, null, 3]], [ws_net_paid#3, i_category#9, i_class#10, spark_grouping_id#11]

(72) HashAggregate
Input [4]: [ws_net_paid#3, i_category#9, i_class#10, spark_grouping_id#11]
Keys [3]: [i_category#9, i_class#10, spark_grouping_id#11]
Functions [1]: [partial_sum(UnscaledValue(ws_net_paid#3))]
Aggregate Attributes [1]: [sum#13]
Results [4]: [i_category#9, i_class#10, spark_grouping_id#11, sum#22]

(73) Exchange
Input [4]: [i_category#9, i_class#10, spark_grouping_id#11, sum#22]
Arguments: hashpartitioning(i_category#9, i_class#10, spark_grouping_id#11, 100), ENSURE_REQUIREMENTS, [plan_id=11]

(74) HashAggregate
Input [4]: [i_category#9, i_class#10, spark_grouping_id#11, sum#22]
Keys [3]: [i_category#9, i_class#10, spark_grouping_id#11]
Functions [1]: [sum(UnscaledValue(ws_net_paid#3))]
Aggregate Attributes [1]: [sum(UnscaledValue(ws_net_paid#3))#15]
Results [7]: [MakeDecimal(sum(UnscaledValue(ws_net_paid#3))#15,17,2) AS total_sum#16, i_category#9, i_class#10, (cast((shiftright(spark_grouping_id#11, 1) & 1) as tinyint) + cast((shiftright(spark_grouping_id#11, 0) & 1) as tinyint)) AS lochierarchy#17, MakeDecimal(sum(UnscaledValue(ws_net_paid#3))#15,17,2) AS _w0#18, (cast((shiftright(spark_grouping_id#11, 1) & 1) as tinyint) + cast((shiftright(spark_grouping_id#11, 0) & 1) as tinyint)) AS _w1#19, CASE WHEN (cast((shiftright(spark_grouping_id#11, 0) & 1) as tinyint) = 0) THEN i_category#9 END AS _w2#20]

(75) Exchange
Input [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]
Arguments: hashpartitioning(_w1#19, _w2#20, 100), ENSURE_REQUIREMENTS, [plan_id=12]

(76) Sort
Input [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]
Arguments: [_w1#19 ASC NULLS FIRST, _w2#20 ASC NULLS FIRST, _w0#18 DESC NULLS LAST], false, 0

(77) Window
Input [7]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20]
Arguments: [rank(_w0#18) windowspecdefinition(_w1#19, _w2#20, _w0#18 DESC NULLS LAST, specifiedwindowframe(RowFrame, unboundedpreceding$(), currentrow$())) AS rank_within_parent#21], [_w1#19, _w2#20], [_w0#18 DESC NULLS LAST]

(78) Project
Output [5]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, rank_within_parent#21]
Input [8]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, _w0#18, _w1#19, _w2#20, rank_within_parent#21]

(79) TakeOrderedAndProject
Input [5]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, rank_within_parent#21]
Arguments: X, [lochierarchy#17 DESC NULLS LAST, CASE WHEN (lochierarchy#17 = 0) THEN i_category#9 END ASC NULLS FIRST, rank_within_parent#21 ASC NULLS FIRST], [total_sum#16, i_category#9, i_class#10, lochierarchy#17, rank_within_parent#21]

(80) AdaptiveSparkPlan
Output [5]: [total_sum#16, i_category#9, i_class#10, lochierarchy#17, rank_within_parent#21]
Arguments: isFinalPlan=true

